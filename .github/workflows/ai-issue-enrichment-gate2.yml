name: AI Issue Enrichment Gate 2
on:
  # Triggered manually by Gate 1 when an issue is validated
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to enrich'
        required: true
        type: string
      issue_title:
        description: 'Issue title'
        required: true
        type: string
      issue_body:
        description: 'Issue body content'
        required: true
        type: string

permissions:
  issues: write
  contents: read
  models: read   # Required for GitHub Models

jobs:
  # Job: Enrich the validated issue with labels and analysis
  enrich:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Log the trigger event for debugging
      - name: Log enrichment trigger
        run: |
          echo "üîç Starting enrichment for issue #${{ github.event.inputs.issue_number }}"
          echo "Title: ${{ github.event.inputs.issue_title }}"

      # Step 2: Use AI to analyze and categorize the issue
      - name: Analyze and enrich validated issue
        id: analyze
        uses: actions/ai-inference@v1
        with:
          prompt: |
            You are an assistant helping maintainers of the Djowda User App platform by enriching validated issues.
            These issues have already passed Gate 1 (legit triage), so they contain enough detail to analyze.
            
            Your task:
            1. **Assign Context Labels**:
               - Issue Type ‚Üí bug, feature-request, improvement
               - Component ‚Üí catalog, orders, account, notifications, payments, performance, ui-ux, other
               - Severity ‚Üí critical, high, medium, low (based on urgency/impact)
            
               Detection rules:
               - BUG: Look for "error", "crash", "not working", "broken", "fails", "expected vs actual"
               - FEATURE: Look for "add", "new", "support", "implement", "would like", "could you"
               - IMPROVEMENT: Look for "optimize", "enhance", "refactor", "slow", "performance", "better"
            
               Component detection keywords:
               - CATALOG: "product", "item", "listing", "search", "category", "filter"
               - ORDERS: "cart", "checkout", "purchase", "order", "payment process"
               - ACCOUNT: "login", "signup", "profile", "password", "authentication"
               - NOTIFICATIONS: "push", "alert", "notification", "reminder", "message"
               - PAYMENTS: "payment", "transaction", "wallet", "refund", "billing"
               - PERFORMANCE: "slow", "lag", "freeze", "loading", "optimization"
               - UI-UX: "design", "layout", "button", "screen", "display", "interface"
            
            2. **Suggest a Short Possible Fix/Hint**:
               - Provide 2-3 sentences MAX of actionable suggestions
               - Focus on immediate workarounds or diagnostic steps
               - Be specific to mobile app context (React Native/Flutter)
               - Include common troubleshooting for the Djowda app
            
               Examples of good hints:
               - "If notifications aren't working, check Settings > Notifications > Djowda App and ensure permissions are enabled. Try logging out and back in to refresh the push token."
               - "For catalog loading issues, pull down to refresh. Clear app cache in Settings if products still don't appear."
               - "Login failures often relate to expired sessions. Try 'Forgot Password' to reset credentials, or check your internet connection."
            
            Severity Guidelines:
            - critical: App crashes, data loss, payment failures, security issues, complete feature breakdown
            - high: Major features broken, frequent errors, blocks user workflow
            - medium: Minor features affected, workaround available, moderate inconvenience
            - low: Cosmetic issues, rare edge cases, nice-to-have improvements
            
            Issue Title: ${{ github.event.inputs.issue_title }}
            Issue Body: ${{ github.event.inputs.issue_body }}
            
            Output format (JSON only, no other text):
            {
              "labels": ["bug", "catalog", "high"],
              "hint": "Check if products load after pull-to-refresh. If not, clear app cache in Settings > Apps > Djowda > Clear Cache and restart the app.",
              "technical_note": "Likely caused by stale cache or API timeout. Check network logs for 404/500 errors on /api/catalog endpoint."
            }
          system-prompt: You are a technical assistant for the Djowda e-commerce mobile app. Provide practical, user-friendly hints and technical notes for maintainers. Be specific and actionable.
          model: openai/gpt-4.1
          temperature: 0.2

      # Step 3: Parse AI response and apply labels to the issue
      - name: Parse AI response and apply labels
        id: apply_labels
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Get the issue number from workflow inputs
              const issueNumber = parseInt('${{ github.event.inputs.issue_number }}');
            
              // Parse the AI response
              const aiResponse = `${{ steps.analyze.outputs.response }}`;
              console.log('AI Response:', aiResponse);
            
              // Extract JSON from the response (handles cases where AI adds extra text)
              const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
              if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
              }
            
              const analysis = JSON.parse(jsonMatch[0]);
              console.log('Parsed analysis:', analysis);
            
              // Enhanced label mapping with emojis
              const labelMapping = {
                // Issue types
                'bug': 'üêû bug',
                'feature-request': '‚ú® feature-request',
                'improvement': 'üõ† improvement',
            
                // Components
                'catalog': 'üõí catalog',
                'orders': 'üì¶ orders',
                'account': 'üë§ account',
                'notifications': 'üîî notifications',
                'payments': 'üí≥ payments',
                'performance': '‚ö° performance',
                'ui-ux': 'üé® ui-ux',
                'other': '‚öôÔ∏è other',
            
                // Priority/Severity
                'critical': 'üî¥ critical',
                'high': 'üü† high',
                'medium': 'üü° medium',
                'low': 'üü¢ low',
            
                // Additional tags
                'needs-reproduction': 'üîç needs-reproduction',
                'good-first-issue': 'üëã good-first-issue',
                'documentation': 'üìö documentation',
                'backend': 'üîß backend',
                'frontend': 'üé® frontend',
                'mobile': 'üì± mobile',
                'android': 'ü§ñ android',
                'ios': 'üçé ios'
              };
            
              // Convert AI-suggested labels to GitHub labels
              const labelsToAdd = analysis.labels
                .map(label => labelMapping[label] || label)
                .filter(label => label);
            
              // Always add the 'triaged' label to show it's been processed
              labelsToAdd.push('‚úÖ triaged');
            
              // Apply all the labels to the issue
              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  issue_number: issueNumber,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: labelsToAdd
                });
                console.log('Successfully added labels:', labelsToAdd);
              }
            
              // Store outputs for use in next steps
              core.setOutput('hint', analysis.hint || 'Our team will review your issue soon.');
              core.setOutput('technical_note', analysis.technical_note || '');
              core.setOutput('labels', labelsToAdd.join(', '));
              core.setOutput('success', 'true');
              core.setOutput('issue_number', issueNumber.toString());
            
              // Check priority level
              const isCritical = labelsToAdd.some(label => label.includes('critical'));
              const isHigh = labelsToAdd.some(label => label.includes('high'));
              core.setOutput('is_critical', isCritical.toString());
              core.setOutput('is_high_priority', (isCritical || isHigh).toString());
            
            } catch (error) {
              console.error('Error processing AI response:', error);
              core.setOutput('success', 'false');
              core.setOutput('hint', 'Our team will review your issue soon and provide assistance.');
              core.setOutput('technical_note', '');
              core.setOutput('labels', '');
              core.setOutput('issue_number', '${{ github.event.inputs.issue_number }}');
              core.setOutput('is_critical', 'false');
              core.setOutput('is_high_priority', 'false');
            }

      # Step 4: Post enrichment comment with analysis results
      - name: Comment with analysis and hint
        if: steps.apply_labels.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.apply_labels.outputs.issue_number }}');
            const hint = `${{ steps.apply_labels.outputs.hint }}`;
            const technicalNote = `${{ steps.apply_labels.outputs.technical_note }}`;
            const labels = `${{ steps.apply_labels.outputs.labels }}`;
            const isCritical = '${{ steps.apply_labels.outputs.is_critical }}' === 'true';
            const isHighPriority = '${{ steps.apply_labels.outputs.is_high_priority }}' === 'true';
            
            // Determine priority emoji and message
            let priorityMessage = '';
            if (isCritical) {
              priorityMessage = '### üö® CRITICAL PRIORITY\nThis issue will receive immediate attention from our team.';
            } else if (isHighPriority) {
              priorityMessage = '### üü† HIGH PRIORITY\nThis issue will be prioritized for review.';
            }
            
            // Create a formatted comment with the enrichment results
            const comment = `<p align="center">
              <img src="https://raw.githubusercontent.com/Moses-Code-Dev/Djowda-UserApp/main/.github/assets/djowda-logo.png" width="100" />
            </p>

            ## ü§ñ AI Analysis Complete

            Thank you for your detailed issue report! I've analyzed it and added relevant labels to help our maintainers prioritize and address it effectively.

            ${priorityMessage}

            ### üìå Applied Labels
            ${labels.split(', ').map(label => `\`${label}\``).join(' ')}

            ### üí° Quick Solution/Workaround
            > **While waiting for a fix, try this:**
            > 
            > ${hint}

            ${technicalNote ? `### üîß Technical Note for Maintainers
            <details>
            <summary>Click to expand technical details</summary>
            
            ${technicalNote}
            </details>` : ''}

            ### üìù What Happens Next?
            1. **Immediate**: Try the suggested workaround above
            2. **Within 24-48h**: A maintainer will review based on priority
            3. **Updates**: You'll be notified of any progress or if we need more info
            4. **Resolution**: We'll update you when a fix is deployed

            ---
            <sub>ü§ñ This automated analysis helps us respond faster. Human review follows based on priority.</sub>
            <sub>üí¨ Feel free to add more details or let us know if the workaround helps!</sub>`;
            
            await github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
            console.log('Posted enrichment comment on issue #' + issueNumber);

      # Step 5: Fallback comment if AI analysis fails
      - name: Fallback comment on analysis failure
        if: steps.apply_labels.outputs.success == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.apply_labels.outputs.issue_number }}');
            
            const comment = `<p align="center">
              <img src="https://raw.githubusercontent.com/Moses-Code-Dev/Djowda-UserApp/main/.github/assets/djowda-logo.png" width="100" />
            </p>

            ## ‚úÖ Issue Validated

            Thank you for your issue report! Our AI assistant is temporarily unable to auto-categorize, but your issue has been marked as valid.

            ### üí° General Troubleshooting Tips
            While waiting for review, you might try:
            - **For app issues**: Force close and restart the Djowda app
            - **For sync problems**: Check your internet connection and pull to refresh
            - **For login issues**: Try logging out and back in, or use "Forgot Password"
            - **For display issues**: Clear the app cache in your device settings

            ### üìù What's Next?
            - A maintainer will manually review and label your issue within 24-48 hours
            - You may be asked for additional details if needed
            - Feel free to add more context or updates as comments

            ---
            <sub>Our team appreciates your contribution to improving the Djowda platform!</sub>`;
            
            await github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
            console.log('Posted fallback comment on issue #' + issueNumber);

      # Step 6: Add enriched label
      - name: Add enriched label
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.apply_labels.outputs.issue_number }}');
            
            // Add the 'ai-enriched' label to indicate AI analysis is complete
            await github.rest.issues.addLabels({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['ü§ñ ai-enriched']
            });
            
            console.log('Added ai-enriched label to issue #' + issueNumber);

      # Step 7: Auto-assign for high priority issues
      - name: Auto-assign to maintainers for high priority issues
        if: steps.apply_labels.outputs.is_high_priority == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.apply_labels.outputs.issue_number }}');
            const isCritical = '${{ steps.apply_labels.outputs.is_critical }}' === 'true';
            
            // TODO: Replace with your actual maintainer GitHub usernames
            const maintainers = ['maintainer1', 'maintainer2'];
            const criticalMaintainers = ['lead-maintainer', 'maintainer1']; // For critical issues
            
            try {
              const assignees = isCritical ? criticalMaintainers : maintainers;
            
              // Assign to maintainers
              await github.rest.issues.addAssignees({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                assignees: assignees.slice(0, 2) // Take first 2
              });
            
              console.log(`Assigned ${isCritical ? 'critical' : 'high priority'} issue #${issueNumber} to maintainers`);
            
              // Post notification for critical issues only
              if (isCritical) {
                await github.rest.issues.createComment({
                  issue_number: issueNumber,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `üö® **CRITICAL ISSUE AUTO-ASSIGNED** üö®\n\nThis critical issue has been auto-assigned for immediate attention.\n\ncc: ${criticalMaintainers.map(m => `@${m}`).join(' ')}`
                });
              }
            
            } catch (error) {
              console.error('Failed to assign maintainers:', error);
              // Continue execution even if assignment fails
            }

      # Step 8: Create project card for tracking (optional)
      - name: Add to project board
        if: steps.apply_labels.outputs.is_high_priority == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            // Optional: Add high-priority issues to a project board
            // This requires a project board to be set up
            console.log('Consider adding issue to project board for tracking');
            
            // Uncomment and configure if you have a project board:
            /*
            const issueNumber = parseInt('${{ steps.apply_labels.outputs.issue_number }}');
            
            await github.rest.projects.createCard({
              column_id: YOUR_COLUMN_ID, // Replace with your "To Do" column ID
              content_id: issueNumber,
              content_type: 'Issue'
            });
            */

      # Step 9: Final success log with summary
      - name: Log completion summary
        run: |
          echo "‚úÖ Enrichment completed for issue #${{ github.event.inputs.issue_number }}"
          echo "üìä Summary:"
          echo "  - Labels: ${{ steps.apply_labels.outputs.labels }}"
          echo "  - Critical: ${{ steps.apply_labels.outputs.is_critical }}"
          echo "  - High Priority: ${{ steps.apply_labels.outputs.is_high_priority }}"
          echo "  - AI Hint Provided: Yes"
          echo "  - Status: ${{ steps.apply_labels.outputs.success }}"